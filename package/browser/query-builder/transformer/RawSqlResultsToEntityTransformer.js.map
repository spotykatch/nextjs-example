{"version":3,"sources":["../browser/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"names":[],"mappings":"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","file":"RawSqlResultsToEntityTransformer.js","sourcesContent":["import { Driver } from \"../../driver/Driver\"\r\nimport { RelationIdLoadResult } from \"../relation-id/RelationIdLoadResult\"\r\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\r\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\r\nimport { Alias } from \"../Alias\"\r\nimport { RelationCountLoadResult } from \"../relation-count/RelationCountLoadResult\"\r\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\r\nimport { OrmUtils } from \"../../util/OrmUtils\"\r\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\r\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\r\nimport { QueryRunner } from \"../..\"\r\nimport { DriverUtils } from \"../../driver/DriverUtils\"\r\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\r\n\r\n/**\r\n * Transforms raw sql results returned from the database into entity object.\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class RawSqlResultsToEntityTransformer {\r\n    /**\r\n     * Contains a hashmap for every rawRelationIdResults given.\r\n     * In the hashmap you will find the idMaps of a result under the hash of this.hashEntityIds for the result.\r\n     */\r\n    private relationIdMaps: Array<{ [idHash: string]: any[] }>\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        protected expressionMap: QueryExpressionMap,\r\n        protected driver: Driver,\r\n        protected rawRelationIdResults: RelationIdLoadResult[],\r\n        protected rawRelationCountResults: RelationCountLoadResult[],\r\n        protected queryRunner?: QueryRunner,\r\n    ) {}\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\r\n     * we need to group our result and we must have some unique id (primary key in our case)\r\n     */\r\n    transform(rawResults: any[], alias: Alias): any[] {\r\n        const group = this.group(rawResults, alias)\r\n        const entities: any[] = []\r\n        group.forEach((results) => {\r\n            const entity = this.transformRawResultsGroup(results, alias)\r\n            if (\r\n                entity !== undefined &&\r\n                !Object.values(entity).every((value) => value === null)\r\n            )\r\n                entities.push(entity)\r\n        })\r\n        return entities\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Groups given raw results by ids of given alias.\r\n     */\r\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\r\n        const map = new Map()\r\n        const keys: string[] = []\r\n        if (alias.metadata.tableType === \"view\") {\r\n            keys.push(\r\n                ...alias.metadata.columns.map((column) =>\r\n                    DriverUtils.buildAlias(\r\n                        this.driver,\r\n                        undefined,\r\n                        alias.name,\r\n                        column.databaseName,\r\n                    ),\r\n                ),\r\n            )\r\n        } else {\r\n            keys.push(\r\n                ...alias.metadata.primaryColumns.map((column) =>\r\n                    DriverUtils.buildAlias(\r\n                        this.driver,\r\n                        undefined,\r\n                        alias.name,\r\n                        column.databaseName,\r\n                    ),\r\n                ),\r\n            )\r\n        }\r\n        rawResults.forEach((rawResult) => {\r\n            const id = keys\r\n                .map((key) => {\r\n                    const keyValue = rawResult[key]\r\n\r\n                    if (Buffer.isBuffer(keyValue)) {\r\n                        return keyValue.toString(\"hex\")\r\n                    }\r\n\r\n                    if (ObjectUtils.isObject(keyValue)) {\r\n                        return JSON.stringify(keyValue)\r\n                    }\r\n\r\n                    return keyValue\r\n                })\r\n                .join(\"_\") // todo: check partial\r\n\r\n            const items = map.get(id)\r\n            if (!items) {\r\n                map.set(id, [rawResult])\r\n            } else {\r\n                items.push(rawResult)\r\n            }\r\n        })\r\n        return map\r\n    }\r\n\r\n    /**\r\n     * Transforms set of data results into single entity.\r\n     */\r\n    protected transformRawResultsGroup(\r\n        rawResults: any[],\r\n        alias: Alias,\r\n    ): ObjectLiteral | undefined {\r\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\r\n        let metadata = alias.metadata\r\n\r\n        if (metadata.discriminatorColumn) {\r\n            const discriminatorValues = rawResults.map(\r\n                (result) =>\r\n                    result[\r\n                        DriverUtils.buildAlias(\r\n                            this.driver,\r\n                            undefined,\r\n                            alias.name,\r\n                            alias.metadata.discriminatorColumn!.databaseName,\r\n                        )\r\n                    ],\r\n            )\r\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(\r\n                (childEntityMetadata) => {\r\n                    return (\r\n                        typeof discriminatorValues.find(\r\n                            (value) =>\r\n                                value ===\r\n                                childEntityMetadata.discriminatorValue,\r\n                        ) !== \"undefined\"\r\n                    )\r\n                },\r\n            )\r\n            if (discriminatorMetadata) metadata = discriminatorMetadata\r\n        }\r\n        let entity: any = metadata.create(this.queryRunner, {\r\n            fromDeserializer: true,\r\n            pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1,\r\n        })\r\n\r\n        // get value from columns selections and put them into newly created entity\r\n        const hasColumns = this.transformColumns(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n            metadata,\r\n        )\r\n        const hasRelations = this.transformJoins(\r\n            rawResults,\r\n            entity,\r\n            alias,\r\n            metadata,\r\n        )\r\n        const hasRelationIds = this.transformRelationIds(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n            metadata,\r\n        )\r\n        const hasRelationCounts = this.transformRelationCounts(\r\n            rawResults,\r\n            alias,\r\n            entity,\r\n        )\r\n\r\n        // if we have at least one selected column then return this entity\r\n        // since entity must have at least primary columns to be really selected and transformed into entity\r\n        if (hasColumns) return entity\r\n\r\n        // if we don't have any selected column we should not return entity,\r\n        // except for the case when entity only contain a primary column as a relation to another entity\r\n        // in this case its absolutely possible our entity to not have any columns except a single relation\r\n        const hasOnlyVirtualPrimaryColumns =\r\n            metadata.primaryColumns.filter(\r\n                (column) => column.isVirtual === false,\r\n            ).length === 0 // todo: create metadata.hasOnlyVirtualPrimaryColumns\r\n        if (\r\n            hasOnlyVirtualPrimaryColumns &&\r\n            (hasRelations || hasRelationIds || hasRelationCounts)\r\n        )\r\n            return entity\r\n\r\n        return undefined\r\n    }\r\n\r\n    // get value from columns selections and put them into object\r\n    protected transformColumns(\r\n        rawResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n        metadata: EntityMetadata,\r\n    ): boolean {\r\n        let hasData = false\r\n        metadata.columns.forEach((column) => {\r\n            // if table inheritance is used make sure this column is not child's column\r\n            if (\r\n                metadata.childEntityMetadatas.length > 0 &&\r\n                metadata.childEntityMetadatas.findIndex(\r\n                    (childMetadata) => childMetadata.target === column.target,\r\n                ) !== -1\r\n            )\r\n                return\r\n\r\n            const value =\r\n                rawResults[0][\r\n                    DriverUtils.buildAlias(\r\n                        this.driver,\r\n                        undefined,\r\n                        alias.name,\r\n                        column.databaseName,\r\n                    )\r\n                ]\r\n            if (value === undefined || column.isVirtual) return\r\n\r\n            // if user does not selected the whole entity or he used partial selection and does not select this particular column\r\n            // then we don't add this column and its value into the entity\r\n            if (\r\n                !this.expressionMap.selects.find(\r\n                    (select) =>\r\n                        select.selection === alias.name ||\r\n                        select.selection ===\r\n                            alias.name + \".\" + column.propertyPath,\r\n                )\r\n            )\r\n                return\r\n\r\n            column.setEntityValue(\r\n                entity,\r\n                this.driver.prepareHydratedValue(value, column),\r\n            )\r\n            if (value !== null)\r\n                // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\r\n                hasData = true\r\n        })\r\n        return hasData\r\n    }\r\n\r\n    /**\r\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\r\n     */\r\n    protected transformJoins(\r\n        rawResults: any[],\r\n        entity: ObjectLiteral,\r\n        alias: Alias,\r\n        metadata: EntityMetadata,\r\n    ) {\r\n        let hasData = false\r\n\r\n        // let discriminatorValue: string = \"\";\r\n        // if (metadata.discriminatorColumn)\r\n        //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\r\n\r\n        this.expressionMap.joinAttributes.forEach((join) => {\r\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\r\n\r\n            // skip joins without metadata\r\n            if (!join.metadata) return\r\n\r\n            // if simple left or inner join was performed without selection then we don't need to do anything\r\n            if (!join.isSelected) return\r\n\r\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\r\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\r\n            if (\r\n                join.relation &&\r\n                !metadata.relations.find(\r\n                    (relation) => relation === join.relation,\r\n                )\r\n            )\r\n                return\r\n\r\n            // some checks to make sure this join is for current alias\r\n            if (join.mapToProperty) {\r\n                if (join.mapToPropertyParentAlias !== alias.name) return\r\n            } else {\r\n                if (\r\n                    !join.relation ||\r\n                    join.parentAlias !== alias.name ||\r\n                    join.relationPropertyPath !== join.relation!.propertyPath\r\n                )\r\n                    return\r\n            }\r\n\r\n            // transform joined data into entities\r\n            let result: any = this.transform(rawResults, join.alias)\r\n            result = !join.isMany ? result[0] : result\r\n            result = !join.isMany && result === undefined ? null : result // this is needed to make relations to return null when its joined but nothing was found in the database\r\n            if (result === undefined)\r\n                // if nothing was joined then simply return\r\n                return\r\n\r\n            // if join was mapped to some property then save result to that property\r\n            if (join.mapToPropertyPropertyName) {\r\n                entity[join.mapToPropertyPropertyName] = result // todo: fix embeds\r\n            } else {\r\n                // otherwise set to relation\r\n                join.relation!.setEntityValue(entity, result)\r\n            }\r\n\r\n            hasData = true\r\n        })\r\n        return hasData\r\n    }\r\n\r\n    protected transformRelationIds(\r\n        rawSqlResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n        metadata: EntityMetadata,\r\n    ): boolean {\r\n        let hasData = false\r\n        this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\r\n            if (\r\n                rawRelationIdResult.relationIdAttribute.parentAlias !==\r\n                alias.name\r\n            )\r\n                return\r\n\r\n            const relation = rawRelationIdResult.relationIdAttribute.relation\r\n            const valueMap = this.createValueMapFromJoinColumns(\r\n                relation,\r\n                rawRelationIdResult.relationIdAttribute.parentAlias,\r\n                rawSqlResults,\r\n            )\r\n            if (valueMap === undefined || valueMap === null) {\r\n                return\r\n            }\r\n\r\n            // prepare common data for this call\r\n            this.prepareDataForTransformRelationIds()\r\n\r\n            // Extract idMaps from prepared data by hash\r\n            const hash = this.hashEntityIds(relation, valueMap)\r\n            const idMaps = this.relationIdMaps[index][hash] || []\r\n\r\n            // Map data to properties\r\n            const properties =\r\n                rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\r\n                    \".\",\r\n                )\r\n            const mapToProperty = (\r\n                properties: string[],\r\n                map: ObjectLiteral,\r\n                value: any,\r\n            ): any => {\r\n                const property = properties.shift()\r\n                if (property && properties.length === 0) {\r\n                    map[property] = value\r\n                    return map\r\n                }\r\n                if (property && properties.length > 0) {\r\n                    mapToProperty(properties, map[property], value)\r\n                } else {\r\n                    return map\r\n                }\r\n            }\r\n            if (relation.isOneToOne || relation.isManyToOne) {\r\n                if (idMaps[0] !== undefined) {\r\n                    mapToProperty(properties, entity, idMaps[0])\r\n                    hasData = true\r\n                }\r\n            } else {\r\n                mapToProperty(properties, entity, idMaps)\r\n                hasData = hasData || idMaps.length > 0\r\n            }\r\n        })\r\n\r\n        return hasData\r\n    }\r\n\r\n    protected transformRelationCounts(\r\n        rawSqlResults: any[],\r\n        alias: Alias,\r\n        entity: ObjectLiteral,\r\n    ): boolean {\r\n        let hasData = false\r\n        this.rawRelationCountResults\r\n            .filter(\r\n                (rawRelationCountResult) =>\r\n                    rawRelationCountResult.relationCountAttribute\r\n                        .parentAlias === alias.name,\r\n            )\r\n            .forEach((rawRelationCountResult) => {\r\n                const relation =\r\n                    rawRelationCountResult.relationCountAttribute.relation\r\n                let referenceColumnName: string\r\n\r\n                if (relation.isOneToMany) {\r\n                    referenceColumnName =\r\n                        relation.inverseRelation!.joinColumns[0]\r\n                            .referencedColumn!.databaseName // todo: fix joinColumns[0]\r\n                } else {\r\n                    referenceColumnName = relation.isOwning\r\n                        ? relation.joinColumns[0].referencedColumn!.databaseName\r\n                        : relation.inverseRelation!.joinColumns[0]\r\n                              .referencedColumn!.databaseName\r\n                }\r\n\r\n                const referenceColumnValue =\r\n                    rawSqlResults[0][\r\n                        DriverUtils.buildAlias(\r\n                            this.driver,\r\n                            undefined,\r\n                            alias.name,\r\n                            referenceColumnName,\r\n                        )\r\n                    ] // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\r\n                if (\r\n                    referenceColumnValue !== undefined &&\r\n                    referenceColumnValue !== null\r\n                ) {\r\n                    entity[\r\n                        rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\r\n                    ] = 0\r\n                    rawRelationCountResult.results\r\n                        .filter(\r\n                            (result) =>\r\n                                result[\"parentId\"] === referenceColumnValue,\r\n                        )\r\n                        .forEach((result) => {\r\n                            entity[\r\n                                rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\r\n                            ] = parseInt(result[\"cnt\"])\r\n                            hasData = true\r\n                        })\r\n                }\r\n            })\r\n\r\n        return hasData\r\n    }\r\n\r\n    private createValueMapFromJoinColumns(\r\n        relation: RelationMetadata,\r\n        parentAlias: string,\r\n        rawSqlResults: any[],\r\n    ): ObjectLiteral {\r\n        let columns: ColumnMetadata[]\r\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n            columns = relation.entityMetadata.primaryColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n            columns = relation.inverseRelation!.joinColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else {\r\n            if (relation.isOwning) {\r\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\r\n            } else {\r\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\r\n                    (joinColumn) => joinColumn,\r\n                )\r\n            }\r\n        }\r\n        return columns.reduce((valueMap, column) => {\r\n            rawSqlResults.forEach((rawSqlResult) => {\r\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n                    valueMap[column.databaseName] =\r\n                        this.driver.prepareHydratedValue(\r\n                            rawSqlResult[\r\n                                DriverUtils.buildAlias(\r\n                                    this.driver,\r\n                                    undefined,\r\n                                    parentAlias,\r\n                                    column.databaseName,\r\n                                )\r\n                            ],\r\n                            column,\r\n                        )\r\n                } else {\r\n                    valueMap[column.databaseName] =\r\n                        this.driver.prepareHydratedValue(\r\n                            rawSqlResult[\r\n                                DriverUtils.buildAlias(\r\n                                    this.driver,\r\n                                    undefined,\r\n                                    parentAlias,\r\n                                    column.referencedColumn!.databaseName,\r\n                                )\r\n                            ],\r\n                            column,\r\n                        )\r\n                }\r\n            })\r\n            return valueMap\r\n        }, {} as ObjectLiteral)\r\n    }\r\n\r\n    private extractEntityPrimaryIds(\r\n        relation: RelationMetadata,\r\n        relationIdRawResult: any,\r\n    ) {\r\n        let columns: ColumnMetadata[]\r\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n            columns = relation.entityMetadata.primaryColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n            columns = relation.inverseRelation!.joinColumns.map(\r\n                (joinColumn) => joinColumn,\r\n            )\r\n        } else {\r\n            if (relation.isOwning) {\r\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\r\n            } else {\r\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\r\n                    (joinColumn) => joinColumn,\r\n                )\r\n            }\r\n        }\r\n        return columns.reduce((data, column) => {\r\n            data[column.databaseName] = relationIdRawResult[column.databaseName]\r\n            return data\r\n        }, {} as ObjectLiteral)\r\n    }\r\n\r\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\r\n        const virtualColumns = this.expressionMap.selects\r\n            .filter(select => select.virtual)\r\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\r\n\r\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\r\n    }*/\r\n\r\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\r\n    private prepareDataForTransformRelationIds() {\r\n        // Return early if the relationIdMaps were already calculated\r\n        if (this.relationIdMaps) {\r\n            return\r\n        }\r\n\r\n        // Ensure this prepare function is only called once\r\n        this.relationIdMaps = this.rawRelationIdResults.map(\r\n            (rawRelationIdResult) => {\r\n                const relation =\r\n                    rawRelationIdResult.relationIdAttribute.relation\r\n\r\n                // Calculate column metadata\r\n                let columns: ColumnMetadata[]\r\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n                    columns = relation.joinColumns\r\n                } else if (\r\n                    relation.isOneToMany ||\r\n                    relation.isOneToOneNotOwner\r\n                ) {\r\n                    columns = relation.inverseEntityMetadata.primaryColumns\r\n                } else {\r\n                    // ManyToMany\r\n                    if (relation.isOwning) {\r\n                        columns = relation.inverseJoinColumns\r\n                    } else {\r\n                        columns = relation.inverseRelation!.joinColumns\r\n                    }\r\n                }\r\n\r\n                // Calculate the idMaps for the rawRelationIdResult\r\n                return rawRelationIdResult.results.reduce((agg, result) => {\r\n                    let idMap = columns.reduce((idMap, column) => {\r\n                        let value = result[column.databaseName]\r\n                        if (\r\n                            relation.isOneToMany ||\r\n                            relation.isOneToOneNotOwner\r\n                        ) {\r\n                            if (\r\n                                column.isVirtual &&\r\n                                column.referencedColumn &&\r\n                                column.referencedColumn.propertyName !==\r\n                                    column.propertyName\r\n                            ) {\r\n                                // if column is a relation\r\n                                value =\r\n                                    column.referencedColumn.createValueMap(\r\n                                        value,\r\n                                    )\r\n                            }\r\n\r\n                            return OrmUtils.mergeDeep(\r\n                                idMap,\r\n                                column.createValueMap(value),\r\n                            )\r\n                        }\r\n                        if (\r\n                            !column.isPrimary &&\r\n                            column.referencedColumn!.referencedColumn\r\n                        ) {\r\n                            // if column is a relation\r\n                            value =\r\n                                column.referencedColumn!.referencedColumn!.createValueMap(\r\n                                    value,\r\n                                )\r\n                        }\r\n\r\n                        return OrmUtils.mergeDeep(\r\n                            idMap,\r\n                            column.referencedColumn!.createValueMap(value),\r\n                        )\r\n                    }, {} as ObjectLiteral)\r\n\r\n                    if (\r\n                        columns.length === 1 &&\r\n                        !rawRelationIdResult.relationIdAttribute.disableMixedMap\r\n                    ) {\r\n                        if (\r\n                            relation.isOneToMany ||\r\n                            relation.isOneToOneNotOwner\r\n                        ) {\r\n                            idMap = columns[0].getEntityValue(idMap)\r\n                        } else {\r\n                            idMap =\r\n                                columns[0].referencedColumn!.getEntityValue(\r\n                                    idMap,\r\n                                )\r\n                        }\r\n                    }\r\n\r\n                    // If an idMap is found, set it in the aggregator under the correct hash\r\n                    if (idMap !== undefined) {\r\n                        const hash = this.hashEntityIds(relation, result)\r\n\r\n                        if (agg[hash]) {\r\n                            agg[hash].push(idMap)\r\n                        } else {\r\n                            agg[hash] = [idMap]\r\n                        }\r\n                    }\r\n\r\n                    return agg\r\n                }, {})\r\n            },\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\r\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\r\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\r\n     */\r\n    private hashEntityIds(relation: RelationMetadata, data: ObjectLiteral) {\r\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data)\r\n        return JSON.stringify(entityPrimaryIds)\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}