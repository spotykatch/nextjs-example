{"version":3,"sources":["../../src/commands/CommandUtils.ts"],"names":[],"mappings":";;;;AAAA,+CAAwB;AACxB,mDAA4B;AAC5B,4DAA2B;AAC3B,oCAAuC;AAEvC,6DAAyD;AACzD,qDAAyD;AAEzD;;GAEG;AACH,MAAa,YAAY;IACrB,MAAM,CAAC,KAAK,CAAC,cAAc,CACvB,kBAA0B;QAE1B,IAAI,qBAAqB,CAAA;QACzB,IAAI;YACA,CAAC;YAAA,CAAC,qBAAqB,CAAC,GAAG,MAAM,IAAA,iCAAmB,EAChD,kBAAkB,CACrB,CAAA;SACJ;QAAC,OAAO,GAAG,EAAE;YACV,MAAM,IAAI,KAAK,CACX,yBAAyB,kBAAkB,MAAM,GAAG,CAAC,OAAO,EAAE,CACjE,CAAA;SACJ;QAED,IACI,CAAC,qBAAqB;YACtB,OAAO,qBAAqB,KAAK,QAAQ,EAC3C;YACE,MAAM,IAAI,KAAK,CACX,qEAAqE,CACxE,CAAA;SACJ;QAED,MAAM,iBAAiB,GAAG,EAAE,CAAA;QAC5B,KAAK,MAAM,aAAa,IAAI,qBAAqB,EAAE;YAC/C,MAAM,UAAU,GAAG,qBAAqB,CAAC,aAAa,CAAC,CAAA;YACvD,2FAA2F;YAC3F,+EAA+E;YAC/E,MAAM,iBAAiB,GACnB,UAAU,YAAY,OAAO,CAAC,CAAC,CAAC,MAAM,UAAU,CAAC,CAAC,CAAC,UAAU,CAAA;YACjE,IAAI,iCAAe,CAAC,YAAY,CAAC,iBAAiB,CAAC,EAAE;gBACjD,iBAAiB,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAA;aAC5C;SACJ;QAED,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,MAAM,IAAI,KAAK,CACX,qEAAqE,CACxE,CAAA;SACJ;QACD,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;YAC9B,MAAM,IAAI,KAAK,CACX,4EAA4E,CAC/E,CAAA;SACJ;QACD,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,iBAAiB,CAAC,SAAiB;QACtC,OAAO,IAAA,gBAAM,EAAC,SAAS,CAAC,CAAA;IAC5B,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,UAAU,CACnB,QAAgB,EAChB,OAAe,EACf,WAAoB,IAAI;QAExB,MAAM,YAAY,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAA;QAC5D,OAAO,IAAI,OAAO,CAAO,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE;YAClC,IAAI,QAAQ,KAAK,KAAK,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC;gBAAE,OAAO,EAAE,EAAE,CAAA;YAE9D,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAA;QACtE,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAgB;QAClC,OAAO,IAAI,OAAO,CAAS,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE;YACpC,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAChC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CACxC,CAAA;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,QAAgB;QACpC,OAAO,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAA;IAClC,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,YAAY,CAAC,uBAA4B;QAC5C,IACI,uBAAuB;YACvB,CAAC,KAAK,CAAC,uBAAuB,CAAC,IAAI,uBAAuB,GAAG,CAAC,CAAC,EACjE;YACE,MAAM,IAAI,oBAAY,CAClB,+DAA+D,uBAAuB,EAAE,CAC3F,CAAA;SACJ;QACD,OAAO,uBAAuB;YAC1B,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAC,OAAO,EAAE;YACrD,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAA;IACpB,CAAC;CACJ;AAvGD,oCAuGC","file":"CommandUtils.js","sourcesContent":["import * as fs from \"fs\"\r\nimport * as path from \"path\"\r\nimport mkdirp from \"mkdirp\"\r\nimport { TypeORMError } from \"../error\"\r\nimport { DataSource } from \"../data-source\"\r\nimport { InstanceChecker } from \"../util/InstanceChecker\"\r\nimport { importOrRequireFile } from \"../util/ImportUtils\"\r\n\r\n/**\r\n * Command line utils functions.\r\n */\r\nexport class CommandUtils {\r\n    static async loadDataSource(\r\n        dataSourceFilePath: string,\r\n    ): Promise<DataSource> {\r\n        let dataSourceFileExports\r\n        try {\r\n            ;[dataSourceFileExports] = await importOrRequireFile(\r\n                dataSourceFilePath,\r\n            )\r\n        } catch (err) {\r\n            throw new Error(\r\n                `Unable to open file: \"${dataSourceFilePath}\". ${err.message}`,\r\n            )\r\n        }\r\n\r\n        if (\r\n            !dataSourceFileExports ||\r\n            typeof dataSourceFileExports !== \"object\"\r\n        ) {\r\n            throw new Error(\r\n                `Given data source file must contain export of a DataSource instance`,\r\n            )\r\n        }\r\n\r\n        const dataSourceExports = []\r\n        for (const fileExportKey in dataSourceFileExports) {\r\n            const fileExport = dataSourceFileExports[fileExportKey]\r\n            // It is necessary to await here in case of the exported async value (Promise<DataSource>).\r\n            // e.g. the DataSource is instantiated with an async factory in the source file\r\n            const awaitedFileExport =\r\n                fileExport instanceof Promise ? await fileExport : fileExport\r\n            if (InstanceChecker.isDataSource(awaitedFileExport)) {\r\n                dataSourceExports.push(awaitedFileExport)\r\n            }\r\n        }\r\n\r\n        if (dataSourceExports.length === 0) {\r\n            throw new Error(\r\n                `Given data source file must contain export of a DataSource instance`,\r\n            )\r\n        }\r\n        if (dataSourceExports.length > 1) {\r\n            throw new Error(\r\n                `Given data source file must contain only one export of DataSource instance`,\r\n            )\r\n        }\r\n        return dataSourceExports[0]\r\n    }\r\n\r\n    /**\r\n     * Creates directories recursively.\r\n     */\r\n    static createDirectories(directory: string) {\r\n        return mkdirp(directory)\r\n    }\r\n\r\n    /**\r\n     * Creates a file with the given content in the given path.\r\n     */\r\n    static async createFile(\r\n        filePath: string,\r\n        content: string,\r\n        override: boolean = true,\r\n    ): Promise<void> {\r\n        await CommandUtils.createDirectories(path.dirname(filePath))\r\n        return new Promise<void>((ok, fail) => {\r\n            if (override === false && fs.existsSync(filePath)) return ok()\r\n\r\n            fs.writeFile(filePath, content, (err) => (err ? fail(err) : ok()))\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Reads everything from a given file and returns its content as a string.\r\n     */\r\n    static async readFile(filePath: string): Promise<string> {\r\n        return new Promise<string>((ok, fail) => {\r\n            fs.readFile(filePath, (err, data) =>\r\n                err ? fail(err) : ok(data.toString()),\r\n            )\r\n        })\r\n    }\r\n\r\n    static async fileExists(filePath: string) {\r\n        return fs.existsSync(filePath)\r\n    }\r\n\r\n    /**\r\n     * Gets migration timestamp and validates argument (if sent)\r\n     */\r\n    static getTimestamp(timestampOptionArgument: any): number {\r\n        if (\r\n            timestampOptionArgument &&\r\n            (isNaN(timestampOptionArgument) || timestampOptionArgument < 0)\r\n        ) {\r\n            throw new TypeORMError(\r\n                `timestamp option should be a non-negative number. received: ${timestampOptionArgument}`,\r\n            )\r\n        }\r\n        return timestampOptionArgument\r\n            ? new Date(Number(timestampOptionArgument)).getTime()\r\n            : Date.now()\r\n    }\r\n}\r\n"],"sourceRoot":".."}